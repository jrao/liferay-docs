## Service Builder 

Service Builder is a model-driven code generation tool built by Liferay to
automate the creation of interfaces and classes for entity modeling, database
persistence, and a service layer. Service Builder takes an XML file (usually
called `service.xml`) as input and generates the necessary model, persistence,
and service layers for your application. It generates most of the common code
needed to implement find, create, update, and delete operations on the database,
allowing you to focus on the higher level aspects of service design.

The service layer generated by Service Builder has an implementation class that
is responsible for retrieving and storing data classes and adding the necessary
business logic around them. This layer can optionally be composed of two layers:
a local service layer and a remote service layer. The local service contains the
business logic and accesses the persistence layer. It can be invoked by client
code running in the same Java Virtual Machine. The remote service usually has
additional code to check security and is meant to be accessible from anywhere
over the Internet or your local network. Service Builder automatically generates
the code necessary to allow access to the remote services using SOAP, JSON, and
Java RMI.

### Benefits of Using Service Builder

Service Builder solves an important portal problem. In a standalone web
application, the database access code can be bundled with the rest of the
application. However, in a portal, web applications are often composed of
multiple portlets that need to access the same data and the same application
logic. Separate web applications (i.e., separate WARs) have separate class
loaders and it's normally difficult to share data and application logic across
class loader boundaries. Service Builder allows different portlets to access the
same data and application logic by creating an underlying framework that's
designed to support a portal environment.

The code generated by Service Builder exists within a single plugin but can
easily be shared across all portlets. This code, bundled in a service JAR,
includes a single access service layer that eliminates the need to manage extra
database connections or worry about code synchronization between portlets.
Using a single access layer allows the use of caching. Since there is only one
data reader/writer, there is no need to worry about cached data becoming
obsolete. If updates need to be made to your web application's service layer,
you can generate a new service JAR and replace the old one without needing to
restart your application server.

Using Service Builder can save developers lots of time since it completely
eliminates the need to write and maintain database access code. The database
access code generated by Service Builder is database-agnostic, as is Liferay
itself. Developers using Service Builder just need to create or edit a
`service.xml` file and run Service Builder to generate a new service JAR for
their project. The service JAR generated by Service Builder includes a model
layer, a persistence layer, a service layer, and related infrastructure. Service
Builder uses Spring for dependency injection and Hibernate for object-relational
mapping but it hides the complexities of using these technologies. The remote
services generated by Service Builder include SOAP utilities and can be accessed
via SOAP, JSON, and Java RMI. Although the number of files generated by Service
Builder can seem intimidating at first, developers only need to work with a few
files in order to make customizations and add business logic.

Originally, Service Builder was built when Liferay used Enterprise Java Beans
(EJBs) for everything. Back then, using EJBs, making even simple changes often
required editing many XML configuration files and Java classes. Service Builder
has evolved since then to use Spring and Hibernate, gaining a lot a flexibility
and allowing changes to be made very simply--in many cases, all that's required
is a change to `service.xml` and a re-run of Service Builder. Liferay isn't a
generic code generation tool; it's specifically designed to meet the needs of
Liferay and Liferay plugin developers. Service Builder may not be the best tool
for everyone but it provides a great degree of consistency to any plugin
developed with it.

In summary, we encourage developers to use Service Builder because it solves the
class loader issue for separate web applications and saves development time.
It's also the technology used to generated Liferay's internal database
persistence code. However, you don't have to use Service Builder for plugin or
portlet development. It's entirely possible to develop plugins by writing custom
code for database persistence using your persistence framework of choice, such
as JPA, Hibernate, or Ibatis. If you're inclined to take this approach, just
remember that you'll have to solve the problem of sharing services across
classloaders on your own. Next, let's roll up our sleeves and learn how to use
Service Builder.

### Configuring Service Builder and Defining Portlet Data

In order to demonstrate how to use Service Builder, let's create an example
portlet project that the Nose-ster organization can use to schedule events. For
our example, we'll create a new Liferay portlet project called
*event-listing-portlet*. We'll define two entities called *events* and
*locations*, representing events that can be scheduled and locations at which
the events can take place. Since events take place at specific locations, an
event entity should be able to take a location entity as an attribute.

---

 ![Tip](../../images/tip-pen-paper.png)**Note:** If you're actually looking for
 a portlet application that can manage events, please consider using Liferay's
 built-in Calendar portlet. The example described in this section is just an
 example that demonstrates how to use Service Builder. The Calendar portlet
 provides many more features than the simple example application described in
 this section.  For information about the built-in calendar portlet, please
 refer to the chapter on Liferay's collaboration suite in [Using Liferay Portal](http://www.liferay.com/documentation/liferay-portal/6.1/user-guide).

---

Liferay portlet projects can contain multiple portlets. We'll create two
portlets in our event-listing-portlet project called *Event Listing Portlet* and
*Location Listing Portlet*. These portlets will allow users to add, edit, or
remove events and locations, display lists of events and locations, search for
particular events and locations, and view the details of individual events or
locations. To follow this example, create a new Liferay portlet project in your
Liferay Plugins SDK called *event-listing-portlet*. In your new project's
`docroot/WEB-INF/src` folder, create a package called
`com.liferay.portlet.library`.

In this new package, create a Java file called `EventListingPortlet.java` and
add the following contents:

    package com.liferay.portlet.library;

    import com.liferay.util.bridges.mvc.MVCPortlet;

    /**
     * Portlet implementation class LibraryBooksPortlet
     */
    public class LibraryBooksPortlet extends MVCPortlet {

    }

In the same package, create another Java file called
`LocationListingPortlet.java` and add the following contents:

    package com.liferay.portlet.library;

    import com.liferay.util.bridges.mvc.MVCPortlet;

    /**
     * Portlet implementation class LibraryBooksPortlet
     */
    public class LibraryBooksPortlet extends MVCPortlet {

    }

Notice that for our custom Event Listing and Location Listing portlets, we are
extending Liferay's MVC Portlet class. We'll add some business logic to these
portlet classes after using Service Builder to create a service layer for our
event and location entities.

The first step in using Service Builder is to define your model classes and
their attributes in a `service.xml` file. In Service Builder terminology, your
model classes (events and locations) are called entities. We've kept the
requirements for our event and location entities fairly simple. Events should
have the following attributes:

- Name
- Description
- Date
- Location Id (An event takes place at a location and we use a location Id to
  specify the location)

Locations should have the following attributes:

- Name
- Description
- Street Address
- City
- State/Province
- Country

Create a `service.xml` file in your project's `docroot/WEB-INF` directory and
add the following contents:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
    <service-builder package-path="com.nosester.portlet.eventlisting">
        <author>jbloggs</author>
        <namespace>Event</namespace>

        <entity name="Event" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="eventId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="long" />
            <column name="modifiedDate" type="long" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="date" type="Date" />
            <column name="locationId" type="long" />

            <!-- Order -->

            <order by="asc">
                    <order-column name="date" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>

        <entity name="Location" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="locationId" type="long" primary="true" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="groupId" type="long" />
            <column name="userId" type="long" />
            <column name="createDate" type="long" />
            <column name="modifiedDate" type="long" />

            <!-- Other fields -->

            <column name="name" type="String" />
            <column name="description" type="String" />
            <column name="streetAddress" type="String" />
            <column name="city" type="String" />
            <column name="stateOrProvince" type="String" />
            <column name="country" type="String" />
            
            <!-- Order -->

            <order by="asc">
                    <order-column name="name" />
            </order>

            <!-- Finder methods -->

            <finder name="GroupId" return-type="Collection">
                    <finder-column name="groupId" />
            </finder>
        </entity>
    </service-builder>

Now let's discuss the tags and attributes that we've added to `service.xml`.

### Overview of `service.xml`

To create a `service.xml` file for your project, use the following steps:

1. Define global information such as the Service Builder package path, author,
   and namespace.

2. Define one or more database entities. Decide whether Service Builder should
   generate local services, remote services, or both.

3. Define the columns (attributes) that each entity should possess.

4. Define a default ordering of entities that are retrieved from the database.

5. Define the finder methods that retrieve objects from the database using
   specified parameters.

We followed these steps to create the `service.xml` for our
event-listing-project example. The first line of `service.xml`, `<?xml
version="1.0" encoding="UTF-8"?>`, just defines the XML version and character
encoding used in the `service.xml` file. The next line, `<!DOCTYPE
service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN"
"http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">`, specifies the
DTD (Document Type Declaration) and provides the DTD's URL. The following line
provides the root element of the Service Builder deployment descriptor: 

    <service-builder package-path="com.liferay.portlet.library">

The `package-path` attribute of the `<service-builder>` element specifies the
package in which the generated service and persistence classes will be
generated. In this example, the classes will be generated in the
`docroot/WEB-INF/service/com/liferay/portlet/library/` and
`docroot/WEB-INF/src/com/liferay/portlet/library/` packages.

Next, we have the `<author>` element:

    <author>Joe Bloggs</author>

The author's name is added to all of the code generated by Service Builder.
After this comes the `<namespace>` element:

    <namespace>LIB</namespace>

Service Builder generates SQL scripts for creating database tables for all the
entities defined in `service.xml`. These database table names will be prepended
with the value specified by the namespace. For example, since our namespace
value is `Event`, the names of the database tables created for our entities will
start with `Event_`. The `<namespace>` element for each Service Builder project
must be unique.

In the rest of our `service.xml` file, we define two entities: 

    <entity name="Event" local-service="true" remote-service="true">

    <entity name="Location" local-service="true" remote-service="true">

The entity name represents the database table you want to create. Remember that
the actual name of the database table is prefixed with the namespace, so in our
example, we'll have two database tables with the names `Event_Event` and
`Event_Location`. Setting the `local-service` attribute to `true` instructs
Service Builder to generate local interfaces for our entity's service. The
default value for `local-service` is `false`. However, the generated service
will reside in our portlet's WAR file and our portlet will be deployed to our
Liferay server. So the service will be local from our Liferay server's point of
view. Setting the `remote-service` attribute to `false` instructs Service
Builder not to generate remote interfaces for the service. The default value for
`remote-service` is `true`. We could build a fully-functional event listing
application without generating remote services so we could set `local-service`
to `true` and `remote-service` to `false` for both of our entities. However,
since we want to demonstrate how to use the web services that Service Builder
generates for our entities, we'll set both `local-service` and `remote-service`
to `true`.

---

 ![Tip](../../images/tip-pen-paper.png)**Tip:** Suppose you have an existing DAO
 service for an entity built using some other framework such as JPA or JingDAO.
 You can set local-service to `false` and remote service to `true` so that the
 methods of your remote Impl class can call the methods of your existing DAO.
 This enables your entity to integrate with Liferay's permission checking system
 and provides access to the web service APIs generated by Service Builder. This
 is a very handy, quite powerful, and often used feature of Liferay.

---

For each of our entities, we specify a number of columns, an order, and a number
of finders. For example, here is the first column we define for the Event
entity:

    <column name="eventId" type="long" primary="true" />

Columns specified in `service.xml` will be created in the database with a data
type appropriate to the specified Java type. Hibernate handles the
object-relational mapping. Accessors in the model class will automatically be
generated for these attributes. The column `name` specifies the name of the
getters and setters that are created for this field of the entity. By default,
it also specifies the name of the database column created in the `Event_Event`
table. The column `type` determines the Java type of this field of the entity.
If a column's `primary-key` attribute is set to `true`, then this column is part
of the primary key of the entity. An entity's primary key is a unique identifier
of the entity. If only one column has `primary-key` set to `true`, then this
column represents the entire primary key of the entity.  This is the case in our
example. However, it's possible for multiple columns within an entity to have
`primary-key` set to `true`. In these cases, a compound key is created.

---

 ![Tip](../../images/tip-pen-paper.png)**Tip:** Always consider adding two
 `long` fields called *groupId* and *companyId* to your data models. The
 *groupId* specifies a particular site within a portal instance and the
 *companyId* specifies a portal instance. These two fields allow your portlet to
 support the multi-tenancy features of Liferay so that each portal instance and
 each site within a portal instance can have independent sets of portlet data.
 You should also consider adding two additional fields called *createDate* and
 *modifiedDate*. You can use these fields to record the times entities were
 created and last edited.

---

After defining the columns of each of our entities, we defined an order. Like
`<column>`, the `<order>` element is a child of the `<entity>` element.

    <order by="asc">
        <order-column name="date" />
    </order>

Set the `<order>` element's `by` attribute to `asc` or `desc` to order entities,
whenever they are retrieved from the database, in ascending or descending order.
Use the `name` attribute of an `<order-column>` child element to determine which
field of the entity should be used for the ordering.

After defining an order for each our entities, we defined a number of finders
for them. `<finder>`, like `<column>` and `<order>`, a child element of the
`<entity>` element.

    <finder name="GroupId" return-type="Collection">
        <finder-column name="group" />
    </finder>

Service Builder creates a finder method for each `<finder>` element that you
specify for your entity. The `name` attribute of the `<finder>` element is used
to construct the finder method name. In the example above, the finder `name` is
`GroupId` so the method generated for this finder will be named `findByGroupId`.
It's a Java coding standard to use camel casing for method names so make sure to
begin your finder names with a capital letter. The `return-type` of the
`<finder>` element determines the return type of the generated finder method.
The `<finder-column>` element inside of the `<finder>` element represents the
database table column that Service Builder creates. Service Builder uses the
`<finder-column>`'s `<name>` attribute to construct the column name of the table
in the database.  When you run Service Builder, your entities' finder methods
are generated in the following classes:

- `/docroot/WEB-INF/service/com/nosester/portlet/eventlisting/service/persistence/*Persistence.java`
- `/docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/persistence/*PersistenceImpl.java` 

The first of these classes is the interface, the second is its implementation.
Now let's run Service Builder and take a closer look at the generated code. To
run Service Builder, run `ant build-service` from your project's root directory.
The Ant tasks are provided by the Liferay Plugins SDK. The following section
provides further details on running Service Builder.

### Generating the Services

To build a service using our `service.xml`, you can either use *Liferay IDE* or
*Liferay Developer Studio* or use a terminal window.

***Using Liferay IDE or Developer Studio:*** From the *Package Explorer*, open
the `service.xml` file found in your `library-project-portlet/docroot/WEB-INF`
folder. By default, the file opens up in the *Service Builder Editor*. Make sure
you are in *Overview* mode. Then, click on the *Build Services* button.

![Figure 10.1: The *Overview* mode in the editor provides a nested outline which you can expand, a form for editing basic Service Builder attributes, and buttons for building services or building web service deployment descriptors.](../../images/service-xml-overview.png)

You should receive a message in your console stating BUILD SUCCESSFUL along with
a list of generated files. We discuss these files in more detail later on in
this section.

The *Overview* mode in Developer Studio's *Service Builder Editor* can be used
to build services or build web service deployment descriptors (WSDDs). The
*Build WSDD* button is next to to the *Build Services* button near the top right
corner of the Service Builder editor's Overview tab. The Service Builder editor
also has *Diagram* and *Source* modes. If you select *Diagram*, you'll see a
graph structured background onto which you can add entities and relationships
from the *Palette* available on the right hand side of the editor. Here is a
view of the editor in *Diagram* mode:

![Figure 10.2: *Diagram* mode in editor](../../images/service-xml-diagram.png)

Lastly, select *Source* mode to edit the XML source directly. Here is a view of
our example `service.xml` shown in the editor's *Source* mode:

![Figure 10.3: *Source* mode in editor](../../images/service-xml-source.png)

The tools provided by Developer Studio make it easy to edit your `service.xml`
file to customize the generated interfaces and classes for your database
persistence and service layers.

***Using the terminal:*** Open a terminal window, navigate to your
`portlets/event-listing-project-portlet` directory, and enter this command:

    ant build-service

When the service has been successfully generated, a BUILD SUCCESSFUL message
appears in the terminal window. You should see that a large number of files have
been generated. An overview of these files generated for our Library Member
entity is provided below. Note that the files listed under Local Service and
Remote Service below are only generated for an entity if `local-service` or
`remote-service` are set to `true`, respectively. Service Builder generates
services for these entities in two locations in our project, using the
package-path that we specified in `service.xml`:

- `docroot/WEB-INF/service/com/nosester/portlet/eventlisting`

- `docroot/WEB-INF/src/com/nosester/portlet/eventlisting`

The `docroot/WEB-INF/service/com/nosester/portlet/eventlisting/` package
contains utility classes and interfaces for the event-listing project. All of
the classes and interfaces in the service folder are packaged in a JAR file
called `event-listing-project-portlet-service.jar` in your `docroot/WEB-INF/lib`
folder. This JAR file is generated each time Service Builder runs. You can place
this JAR file on your application server's global classpath to make your
project's services available to other projects. This could allow a portlet in a
different project, for example, to create, update, or delete Events or
Locations.

The `docroot/WEB-INF/src/com/nosester/portlet/eventlisting` package contains the
implementation of the interfaces defined in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` package. It belongs
to the library project's classpath but is not available outside of the library
project.  Service Builder generates classes and interfaces belonging to the
persistence layer, service layer, and model layer in the
`docroot/WEB-INF/service/com/nosester/portlet/eventlisting` and
`docroot/WEB-INF/src/com/nosester/portlet/eventlisting` packages. Let's take a
closer look at the classes and interfaces generated for Events. The ones
generated for Locations are similar.

-   Persistence

    - `EventPersistence`: Event persistence interface which defines CRUD methods
      for the Event entity such as create(), remove(), countAll(), find(),
      findAll(), etc. `@generated`

    - `EventPersistenceImpl`: Event persistence implemenation class which
      implements `EventPersistence`. `@generated`

    - `EventUtil`: Event persistence utility class which wraps
      `EventPersistenceImpl` and provides direct access to the database for CRUD
      operations. This utility should only be used by the service layer; in your
      portlet classes, use `EventLocalServiceUtil` or `EventServiceUtil`
      instead. `@generated`

    ![Figure 10.3: Service Builder generates these persistence classes and interfaces. You shouldn't (and won't need to) customize any of these classes or interfaces.](../../images/service-builder-persistence-diagram.uml.png)

-   Local Service (only generated for an entity if an entity's `local-service`
    attribute is set to `true` in `service.xml`)

    - `EventLocalService`: Event local service interface. `@generated`

    - **`EventLocalServiceImpl`**: Event local service implementation. This is
      the only class within the local service that you should modify manually.
      You can add custom business logic here. For any custom methods added here,
      Service Builder add corresponding methods to the `EventLocalService`
      interface the next time it runs.

    - `EventLocalServiceBaseImpl`: Event local service base implementation. This
      is an abstract class. Service Builder injects a number of instances of
      various service and persistence classes into this class. `@generated`
      `@abstract`

    - `EventLocalServiceUtil`: Event local service utility class which wraps
      `EventLocalServiceImpl` and serves as the primary local access point to
      the service layer. `@generated`

    - `EventLocalServiceWrapper`: Event local service wrapper which implements
      `EventLocalService`. This class is designed to be extended and it allows
      developers to customize the local Event services. Customizing services
      should be done via a hook plugin. `@generated` 

    ![Figure 10.3: Service Builder generates these service classes and interfaces. Only EventLocalServiceImpl allows custom methods to be added to the service layer.](../../images/service-builder-service-diagram.uml.png)

-   Remote Service (only generated for an entity if an entity's `remote-service`
    attribute is set to `true` in `service.xml`)

    - `EventService`: Event remote service interface. `@generated`

    - **`EventServiceImpl`**: Event remote service implementation. This is the
      only class within the remote service that you should modify manually.
      Here, you can write code that adds additional security checks and invokes
      the local services. For any custom methods added here, Service Builder add
      corresponding methods to the `EventService` interface the next time it
      runs.

    - `EventServiceBaseImpl`: Event remote service base implementation. This is
      an abstract class. `@generated` `@abstract`

    - `EventServiceUtil`: Event remote service utility class which wraps
      `EventServiceImpl` and serves as the primary remote access point to the
      service layer. `@generated`

    - `EventServiceWrapper`: Event remote service wrapper which implements
      `EventService`. This class is designed to be extended and it allows
      developers to customize the remote Event services.  Customizing services
      should be done in a hook plugin. `EventServiceImpl` `@generated`

    - `EventServiceSoap`: Event SOAP utility which the remote `EventServiceUtil`
      remote service utility can access. `EventServiceUtil` `@generated`

    - `EventSoap`: Event SOAP model, similar to `EventModelImpl`. `EventSoap` is
      serializable; it does not implement `Event`. `@generated`

    <!-- Is this class obsolete? This class wasn't generated for me during
    testing -->
    - `EventServiceHttp`: HTTP remote service, proxies
      `EventServiceUtil` `@generated`

-   Model

    -   `EventModel`: Event base model interface. This interface and its
        `EventModelImpl` implementation serve only as a container for the
        default property accessors generated by Service Builder. Any helper
        methods and all application logic should be added to `EventImpl`.
        `@generated`

    -   `EventModelImpl`: Event base model implementation. `@generated`

    -   `Event`: Event model interface which extends `EventModel`. `@generated`

    - **`EventImpl`**: Event model implementation. You can use this class to add
      helper methods and application logic to your model. If you don't add any
      helper methods or application logic, only the auto-generated field getters
      and setters will be available. Whenever you add custom methods to this
      class, Service Builder adds corresponding methods to the `Event` interface
      the next time it runs.

    -   `EventWrapper`: Event wrapper, wraps `Event`. `@generated`

    ![Figure 10.3: Service Builder generates these model classes and interfaces. Only EventImpl allows custom methods to be added to the service layer.](../../images/service-builder-model-diagram.uml.png)

Out of all of all the classes generated by Service Builder, only three should be
manually modified: `EventLocalServiceImpl`, `EventServiceImpl` and `EventImpl`.
If you manually modify the other classes, your changes will be overwritten the
next time Service Builder runs.

Each file that Service Builder generates is assembled from an associated
Freemarker template. You can find Service Builder's Freemarker templates in the
`com.liferay.portal.tools.servicebuilder.dependencies` package of Liferay's
`portal-impl/src` folder. For example, if you want to find out how a
`*ServiceImpl.java` file is generated, just look at the `service_impl.ftl`
template.

### Writing the Local Service Class 

In the file overview above, notice that `EventLocalService` is the interface for
the local service. It contains the signatures of every method in
`EventLocalServiceBaseImpl` and `EventLocalServiceImpl`.
`EventLocalServiceBaseImpl` contains a few automatically generated methods
providing common functionality. Since this class is generated, you should never
modify it, or your changes will be overwritten the next time you run Service
Builder. Instead, all custom code should be placed in `EventLocalServiceImpl`.

Open the following file:

    /docroot/WEB-INF/src/com/nosester/portlet/eventlisting/service/impl/EventLocalServiceImpl.java

We will add the database interaction methods to this service layer class. Add
the following method to the `EventLocalServiceImpl` class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment();
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now.getTime());
        event.setModifiedDate(now.getTime());
        
        return super.addEvent(event);
    }

    public Event updateEvent(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now.getTime());
        
        return super.updateEvent(event);
    }

    public List<Event> getEventsByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId);
    }

    public List<Event> getEventsByGroupId(long groupId, int start, int end) throws SystemException {
        
        return eventPersistence.findByGroupId(groupId, start, end);
    }

    public int getEventsCountByGroupId(long groupId) throws SystemException {
        
        return eventPersistence.countByGroupId(groupId);
    }	

In order to add an Event to the database, we need an ID for the Event. Liferay
provides a counter service which we use call to obtain a unique Id for adding a
new Event. It's possible to use the increment() method of Liferay's
CounterLocalServiceUtil class but Service Builder already makes an instance of
CounterLocalService available to EventLocalServiceBaseImpl, which our
EventLocalServiceImpl class extends by Spring via dependency injection. See
EventLocalServiceBaseImpl for a list of all the beans that Spring makes
available for use. These include the following:

- `eventLocalService`
- `eventPersistence`
- `locationLocalService`
- `locationPersistence`
- `counterLocalService`
- `resourceLocalService`
- `resourceService`
- `resourcePersistence`
- `userLocalService`
- `userService`
- `userPersistence`

It's a best practice to use the injected class's increment() method rather than
calling Liferay's CounterLocalService's increment() method since using the
injected class does not require an extra database transaction whereas calling
Liferay's CounterLocalServiceUtil class does.

    long eventId = counterLocalService.increment(Event.class.getName());

We use the generated eventId as the eventId of the new Event:

    Event event = libraryMemberPersistence

Next, we set the createDate and modifiedDate of our Event to the current time.
Lastly, we return the Event created by the generated addEvent(...) method of
`EventLocalServiceBaseImpl`.

Note: Our implementation of addEvent(...) is a simple one since we just called
addEvent(...) method generated in `EventLocalServiceBaseImpl`. We could replace
or overload the addEvent(...) method we added to `EventLocalServiceImpl` by
adding another addEvent(...) method with a different signature: instead of
passing an existing Event to the addEvent(...) method, we could instead pass the
required parameters and call the eventPersistence object's create method to
create a new Event. Then we could use the method's parameters to populate the
new Event's fields and return the Event.  (eventPersistence is one of the Spring
beans injected into `EventLocalServiceBaseImpl` by Service Builder.) 

Before you can use any custom methods that you added to `EventLocalServiceImpl`
class, you must add its signature to the `EventLocalService` interface by
running Service Builder again.

***Using Developer Studio:*** As we did before, open your `service.xml` file and
make sure you are in the *Overview* mode. Then, select *Build Services*.

***Using the terminal:*** Navigate to the root directory of your portlet in the
terminal and run:

    ant build-service

Service Builder looks through `EventLocalServiceImpl` and automatically copies
the signatures of each method into the interface. You can now add a new Event to
the database by making the following call:

    EventLocalServiceUtil.addEvent(event);

Of course, we need to create an event before we can make this call. This is one
reason to replace or overload the addEvent(...) we added to
`EventLocalServiceImpl`, which we noted as an option above. In addition to all
of the Java classes, Service Builder also generates a `service.properties` file.
Let's examine that next.

### Calling Local Liferay Services

Once Service Builder has generated our portlet project's services, we can call
them in our portlet classes. We can call any methods of `EventLocalServiceUtil`
or `LocationLocalServiceUtil` in our `EventListingPortlet` and
`LocationListingPortlet` classes. For our example, we'd like the Event Listing
portlet to be able to perform CRUD operations on Events and our Library Book
portlet to be able to perform CRUD operations on Locations. To this end, we'll
create the following methods for our EventListingPortlet class and similar ones
for our LocationListingPortlet class:

- addEvent
- updateEvent
- deleteEvent

Replace the contents of your `EventListingPortlet.java` file with the following:

    package com.nosester.portlet.eventlisting;

    import java.text.SimpleDateFormat;

    import javax.portlet.ActionRequest;
    import javax.portlet.ActionResponse;
    import javax.portlet.PortletRequest;

    import com.liferay.portal.kernel.log.Log;
    import com.liferay.portal.kernel.log.LogFactoryUtil;
    import com.liferay.portal.kernel.util.ParamUtil;
    import com.liferay.portal.kernel.util.WebKeys;
    import com.liferay.portal.theme.ThemeDisplay;
    import com.liferay.util.bridges.mvc.MVCPortlet;
    import com.nosester.portlet.eventlisting.model.Event;
    import com.nosester.portlet.eventlisting.model.impl.EventImpl;
    import com.nosester.portlet.eventlisting.service.EventLocalServiceUtil;

    public class EventListingPortlet extends MVCPortlet {

        public void addEvent(ActionRequest request, ActionResponse response)
                        throws Exception {

            Event event = eventFromRequest(request);

            EventLocalServiceUtil.addEvent(event);

            sendRedirect(request, response);
        }
        
        public void updateEvent(ActionRequest request, ActionResponse response)
                throws Exception {

            Event event = eventFromRequest(request);

            EventLocalServiceUtil.updateEvent(event);

            sendRedirect(request, response);
        }

        public void deleteEvent(ActionRequest request, ActionResponse response)
                throws Exception {

            long eventId = ParamUtil.getLong(request, "eventId");

            EventLocalServiceUtil.deleteEvent(eventId);

            sendRedirect(request, response);
        }	

        private Event eventFromRequest(PortletRequest request) {

            EventImpl event = new EventImpl();

            event.setEventId(ParamUtil.getLong(request, "eventId"));
            event.setName(ParamUtil.getString(request, "name"));
            event.setDescription(ParamUtil.getString(request, "description"));
            event.setLocationId(ParamUtil.getLong(request, "locationId"));
            
            SimpleDateFormat dateFormat = new SimpleDateFormat();
            event.setDate(ParamUtil.getDate(request, "date", dateFormat));
            
            ThemeDisplay themeDisplay = (ThemeDisplay) request
                            .getAttribute(WebKeys.THEME_DISPLAY);

            event.setUserId(themeDisplay.getUserId());
            event.setCompanyId(themeDisplay.getCompanyId());
            event.setGroupId(themeDisplay.getScopeGroupId());
            
            return event;
        }

        private static Log _log = LogFactoryUtil.getLog(EventListingPortlet.class);

    }

Our Event Listing portlet's add, update, and delete methods call the appropriate
methods of `EventLocalServiceUtil`. The eventFromRequest(...) method is a
convenience method that returns an event from a portlet request, e.g., from the
HTML form fields of the `edit_event.jsp` page. The getter methods of Liferay's
ParamUtil class such as getLong(...) and getString(...) return default values
like `0` or `""` if request parameter is not available from the portlet request.
When adding a new event, for example, no eventId is available so
`ParamUtil.getLong("request", "eventId")` returns `0`. The Event portlet's
addEvent(...) method calls `EventLocalServiceUtil`'s addEvent(...) method. The
eventId for the new event is generated at the service layer in the addEvent(...)
method that we added to the `EventLocalServiceImpl` class. The
`EventLocalServiceUtil` generated for us by Service Builder contains various
CRUD methods including the following:

- createEvent
- addEvent
- deleteEvent
- updateEvent
- fetchEvent
- getEvent

The methods listed in the following figure are all generated by Service Builder
and are available to be called by our Event Listing portlet class.

![Figure 10.4: Our Library Member portlet class can access these methods of `LibraryMemberLocalServiceUtil`, many of which enable CRUD operations.](../../images/local-service-util-outline.png)

Portlet classes should only have access to the LocalServiceUtil classes.
LocalServiceUtil classes, in turn, call the LocalServiceImpl classes. Notice in
the figure above that `EventLocalServiceUtil` has a private instance variable
called `_service`. `_service` is an instance variable of type
`EventLocalService` which gets an instance of `EventLocalServiceImpl` at runtime
via dependency injection. So all the methods of `EventLocalServiceUtil`
internally call corresponding methods of `EventLocalServiceImpl` at runtime to
perform CRUD operations.

### Writing the Remote Service Class

Many default Liferay services are available as web services. Liferay exposes its
web services via SOAP and JSON web services. If you're running Liferay locally
on port 8080, visit the following URL to browse Liferay's default SOAP web
services:

    http://localhost:8080/api/axis

To browse Liferay's default JSON web services, visit this URL:

    http://localhost:8080/api/jsonws/

These web services APIs can be accessed by many different kinds of clients
including non-portlet and even non-Java clients. You can use Service Builder to
generate similar remote services for your projects' custom entities. When you
run Service Builder with the `remote-service` attribute set to `true` for an
entity, all the classes, interfaces, and files required to support both SOAP and
JSON web services are generated for your entity. Service Builder generates
methods that call existing services but it's up to the developer to implement
the methods that are exposed remotely. Let's use Service Builder to generate
remote services for the Nose-ster Event Listing portlet project's custom
entities. We'll implement a few methods for the Event Listing portlet that can
be called remotely via SOAP or JSON web services.

We implemented our local service methods in `EventLocalServiceImpl`. Similarly,
we'll implement our remote service methods in `EventServiceImpl`. Add the
following methods to your `EventServiceImpl` class:

    public Event addEvent(Event event) throws SystemException {
        
        long eventId = counterLocalService.increment(Event.class.getName());
        event.setEventId(eventId);
        
        Date now = new Date();
        event.setCreateDate(now.getTime());
        event.setModifiedDate(now.getTime());
        
        return eventLocalService.addEvent(event);
    }
    
    public Event update(Event event) throws SystemException {
        
        Date now = new Date();
        event.setModifiedDate(now.getTime());
        
        return eventLocalService.updateEvent(event);
    }	
    
    public Event delete(Event event) throws SystemException {
        
        return eventLocalService.deleteEvent(event);
    }	

    public Event deleteEvent(long eventId) throws PortalException, SystemException {
            
            return eventLocalService.deleteEvent(eventId);
    }

Notice your calls to eventLocalService's add, update, and delete methods.
eventLocalService is a Spring bean of type `EventLocalServiceImpl` that's
injected into `EventServiceBaseImpl` by Service Builder. See
`EventServiceBaseImpl` for a complete list of the Spring beans available in
`EventServiceImpl`. These include the following:

- eventLocalService
- eventService
- eventPersistence
- locationLocalService
- locationService
- locationPersistence
- counterLocalService
- resourceLocalService
- resourceService
- resourcePersistence
- userLocalService
- userService
- userPersistence

Notice also that we overloaded the deleteEvent(...) method of
`EventServiceImpl`. We did this to simplify our example of calling remote web
services in the next section; it's much simpler to pass an eventId as a
parameter over web services that to pass an entire event object.

After you finish adding imports to `EventServiceImpl`, save the class and run
Service Builder again. In addition to updating the Java classes and interfaces,
Service Builder updates the your project's `/docroot/js/service.js` file so your
custom services can be registered with Liferay. This allows them to be called by custom taglibs and be made available as JSON web services:

    Liferay.Service.register("Liferay.Service.Event", 
    "com.nosester.portlet.eventlisting.service", "event-listing-portlet");

    Liferay.Service.registerClass(
        Liferay.Service.Event, "Event",
        {
                addEvent: true,
                update: true,
                delete: true
        }
    )

Liferay uses Apache Axis to make SOAP web services available. Axis requires a
Web Service Deployment Descriptior (WSDD) to be generated in order to make the
SOAP web services available. Liferay provides a `build-wsdd` Ant target which
generates the WSDD. In Liferay IDE or Developer Studio, when viewing
`service.xml` from the Overview tab, there's a button in the top-right corner of
the screen that's a shortcut for calling the Build WSDD target. Once the WSDD
has been generated and your portlet project has been deployed, a Web Services Definition Language will be available. 

### Calling Remote Liferay Services

To access the WSDL document produced by the `build-wsdd` Ant target in the
previous section, visit the following URL:

    http://localhost:8080/event-listing-portlet/api/axis/Plugin_Event_EventService?wsdl 

This URL lists all of your portlet project's available SOAP web services. Of
course, your portlet project must be deployed for this URL to be available.
Once the WSDL for your SOAP web services is available, many different types of
clients written in different languages can consume your web services. In
production, make sure to integrate your applications with Liferay's permissions
system to implement security checks for all your remote service methods.

You can also call your project's remote Service Builder-generated web services
using the JSON-based protocol. To view the available JSON web-services, visit
the following URL:

    http://localhost:8080/event-listing-portlet/api/jsonws

Whereas you'd need to create a client before invoking a SOAP web service
(alternatively, you could manually craft a URL), you can invoke JSON web
services directly from your browser. To test the JSON web services generated for
your Event Listing portlet project, visit the JSON web services URL for your
portlet listed above and then click on *delete-event*.

![Figure 11.x: You'll see a page displaying the name of the service method, its required parameters, its return type, possible exceptions that can be thrown, and a form for entering the parameter.](../../images/invoking-sb-generated-json-ws.png)

The only method we need to invoke our remote deleteEvent is an eventId. Add an
event to the database if you haven't done so already and then check the
Event_Event table in your database for its eventId. Enter the value of the
eventId into the eventId field under the Execute heading and then click
*Invoke*. If your service call succeeded, you should see result of your service
call: the event that was deleted. You can also examine alternate equivalent
methods of calling the same remote service via JavaScript, curl, and URL.

### Custom SQL Queries

Service Builder allows searching for entities via custom SQL queries. For
example, consider our Nose-ster event listing portlet project. Suppose we'd like
to add a search form to allow searching for events based on the event's name,
description, and location name. Since the location name is not in the
`Event_Event` table (although the locationId is), we can't implement this kind
of search using the event entity's finder methods. We need to perform a joined
searched across both the `Event_Event` and the `Event_Location` tables. To
accomplish this, we can use a custom SQL query.

In order to use custom queries, we need to create a custom finder class. This
class should be created in the `com.nosester.portlet.eventlisting` package of
our project's `docroot/WEB-INF/src` folder. This package was created by Service
Builder. The class we create should extend
`com.liferay.portal.service.persistence.impl.BasePersistenceImpl<Event>`. For
our example, we'll create a class called `EventFinderImpl` in this folder with
the following contents:

    package com.nosester.portlet.eventlisting.service.persistence;

    import com.liferay.portal.service.persistence.impl.BasePersistenceImpl;
    import com.nosester.portlet.eventlisting.model.Event;

    public class EventFinderImpl extends BasePersistenceImpl<Event> {

    }

Once you've created this class, run Service Builder again. Service Builder
generates `EventFinder` interface and the `EventFinderUtil` class for us in our
project's `docroot/WEB-INF/service` folder. After running Service Builder again, make your `EventFinderImpl` class implement the generated `EventFinder` interface:

    public class EventFinderImpl extends BasePersistenceImpl<Event> implements EventFinder {

    }

Don't forget to implement the generated interface! It's an easy step to forget.
Now we can create our custom query method in our `EventFinderImpl` class.

### Overview of `portlet-model-hints.xml`

Service Builder generates a number of XML configuration files in your project's
`docroot/WEB-INF/src/META-INF` folder. Service Builder uses most of these files
to manage Spring and Hibernate configurations. Don't modify the Spring or
Hibernate configuration files; your changes will be overwritten the next time
Service Builder runs. However, there's one configuration file that you can
safely edit which allows you to customize details of your Service Builder
generated models: `portlet-model-hints.xml`. This file allows you to configure
how model fields are displayed using the `aui` taglib. It also allows you to
adjust the size of the columns of database tables. Liferay has its own model
hints XML configuration file called `portal-model-hints.xml` which you can find
in Liferay's `portal-impl/classes/META-INF` folder. Liferay's model hints
configuration file contains many hint examples so you can refer to it for
reference when customizing your `portlet-model-hints.xml`.

Examine your project's `docroot/WEB-INF/src/META-INF/portlet-model-hints.xml`
file. If you're following the Event Listing portlet example, Service Builder
should have created the file with the following contents:

    <?xml version="1.0"?>

    <model-hints>
        <model name="com.nosester.portlet.eventlisting.model.Event">
            <field name="eventId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="date" type="Date />
            <field name="locationId" type="long" />
        </model>
        <model name="com.nosester.portlet.eventlisting.model.Location">
            <field name="locationId" type="long" />
            <field name="companyId" type="long" />
            <field name="groupId" type="long" />
            <field name="userId" type="long" />
            <field name="createDate" type="long" />
            <field name="modifiedDate" type="long" />
            <field name="name" type="String" />
            <field name="description" type="String" />
            <field name="streetAddress" type="String" />
            <field name="city" type="String" />
            <field name="stateOrProvince" type="String" />
            <field name="country" type="String" />
        </model>
    </model-hints>

Your `portlet-model-hints.xml` file has a root-level model-hints tag that
contains model tags. Each model tag must have a name attribute specifying the
full package name of the model class. Each model tag must also contain a field
name for attribute of the model specifying the field name and type as
attributes. To add hints to a field, add a hint tag inside of a field tag,
specify the hint's name as an attribute and the value of the hint within in the
hint tag. For example, the display-width hint allows you to specify the width of
a model's field as it appears on an AUI form. The default is 350. To specify a
display-width of 50 pixels for the Event model's name field, replace the `<field
name="name" type="String" />` line with the following:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
    </field>

In order to see the effect of the display-width hint on the Event model's name
field, you have to run Service Builder again and redeploy your portlet project.
Changing the display-width doesn't actually limit the number of characters that
can be entered into the name field; it's just a way to control the width of the
AUI input form field. To configure the maximum size of a model field's database
column (i.e., the maximum number of characters that can be saved in the field),
use the max-length hint. The default max-length is 75. If you'd like to allow
Event names of up to 100 characters to be saved, add another hint element inside
of your name field element:

    <field name="name" type="String">
        <hint name="display-width">50</hint>
        <hint name="max-length">100</hint>
    </field>

Remember to run Service Builder and redeploy your portlet project after updating
`portlet-model-hints.xml`. To test your max length setting, add a new event with
a name consisting of between 75 and 100 characters. The following table
describes some commonly used model hints.

**Model Hint Values and Descriptions**

Name | Value Type | Description | Default
:--: | :--------: | :---------: | :-----:
auto-escape | boolean | sets whether text values should be escaped via HtmlUtil.escape | true
day-nullable | boolean | allows the day to be null in a date field | false
default-value | String | sets the default value for a field | (empty String)
display-height | integer | sets the display height of the form field rendered using the aui taglib | 15
display-width | integer | sets the display width of the form field rendered using the aui taglib | 350
max-length | integer | sets the maximum column size for SQL file generation | 75
month-nullable | boolean | allows the month to be null in a date field | false
upper-case | boolean | converts all characters to upper case | false
year-nullable | boolean | allows the year to be null in a date field | false
year-range-delta | integer | specifies the number of years to display from today's date in a date field rendered with the aui taglib | 5

You can use the default-hints element to define a list of hints to be applied to
every field of a model. For example, adding the following element inside of a
model element applies a display-width of 300 to each element of the model:

    <default-hints>
        <hint name="display-width">300</hint>
    </default-hints>

You can define hint-collection elements inside of the model-hints element to
define a list of hints that can applied together. A hint collection must be
specified with a name. Model fields can apply a hint collection by referring to
the hint collection's name. For example, Liferay's `portal-model-hints.xml`
defines the following hint collections:

    <hint-collection name="CLOB">
        <hint name="max-length">2000000</hint>
    </hint-collection>
    <hint-collection name="URL">
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="TEXTAREA">
        <hint name="display-height">105</hint>
        <hint name="display-width">500</hint>
        <hint name="max-length">4000</hint>
    </hint-collection>
    <hint-collection name="SEARCHABLE-DATE">
        <hint name="month-nullable">true</hint>
        <hint name="day-nullable">true</hint>
        <hint name="year-nullable">true</hint>
        <hint name="show-time">false</hint>
    </hint-collection>

If you define the same SEARCHABLE-DATE collection as above, you can apply it to
your Event model's date field by using a hint-collection element:

    <field name="date" type="Date">
        <hint-collection name="SEARCHABLE-DATE" />
    </field>

Remember to run Service Builder and redeploy your project after updating your
`portlet-model-hints.xml` file.

### Overview of `service.properties`

Service Builder generates the properties file `service.properties` in the `src`
directory of your service. Liferay Portal uses the properties in this file to
alter your service's database schema and load Spring configuration files to
support deployment of your service. You should not modify this file, but rather
make any necessary overrides in a `service-ext.properties` file in the `src`
folder.

The only property that you may need to override from this file is
`build.auto.upgrade`. Setting `build.auto.upgrade=false` in your
`service-ext.properties` prevents Liferay from trying to automatically apply any
changes to the database model when a new version of the plugin is deployed. This
is needed in projects in which it is preferred to manually manage the changes to
the database or in which the SQL schema has been modified manually after
generation by Service Builder.

### Built-In Liferay Services 

In addition to the services you create using Service Builder, your portlets may
also access a variety of services built into Liferay. These include the
following:

- `UserService`

- `OrganizationService`

- `GroupService`

- `CompanyService`

- `ImageService`

- `LayoutService`

- `PermissionService`

- `UserGroupService`

- `RoleService`

For more information on these services, see Liferay's Javadocs at
[http://docs.liferay.com/portal/6.1/javadocs/](http://docs.liferay.com/portal/6.1/javadocs/).
